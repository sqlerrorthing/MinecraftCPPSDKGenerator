package me.sqlerrorthing.generator.impl

import me.sqlerrorthing.Config
import me.sqlerrorthing.ast.IClass
import me.sqlerrorthing.ast.IField
import me.sqlerrorthing.ast.IMethod
import me.sqlerrorthing.generator.Generator
import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger
import java.io.File
import java.util.*


private const val BASE_HEADER_NAME = "sdk.hpp"
private const val BASE_CPP_NAME = "sdk.cpp"
private const val JNI_INCLUDE = "#include <jni.h>"
private const val BASE_INCLUDE = "#include <sdk.hpp>"
private const val BASE_NAMESPACE = "MinecraftSDK"

private const val BASE_WARNING = """
            // WARNING: This code was automatically generated by MinecraftCppSDK.
            // It is highly recommended to not modify this file directly.
            // Any changes made to this file will be overwritten by the next generation. 
        """//.trimIndent()

private val logger: Logger = LogManager.getLogger(CPPGenerator::class.java)


operator fun File.div(other: String): File {
    return this.resolve(other)
}

fun String.upperFirstLetter(): String {
    if (this.length <= 1) return this.uppercase(Locale.getDefault())

    return this.substring(0, 1).uppercase(Locale.getDefault()) + this.substring(1)
}



object CPPGenerator : Generator {

    override fun generate(config: Config, parsed: List<IClass>) {
        logger.debug("Generating base.hpp")
        (config.outFolder / BASE_HEADER_NAME).writeText(generateBaseHeaderFile(parsed))
        (config.outFolder / BASE_CPP_NAME).writeText(generateBaseCppFile())

        parsed.forEach {
            try {
                logger.debug("Staring generating .h class ${it.name.normalName}")
                generateClass(config, it)
            } catch (e: Exception) {
                logger.error("Failed to generate class ${it.name.normalName}", e)
            }
        }
    }

    private fun generateClass(config: Config, `class`: IClass) {

        val dstFile = config.outFolder / (`class`.name.normalName + ".hpp")
        dstFile.parentFile.mkdirs()
        dstFile.createNewFile()

        val sb = StringBuilder()
        sb.append(BASE_WARNING.trimIndent())
        sb.appendLine()
        sb.appendLine()
        logger.debug("Insert warning msg into header file")

        val (definitionPre, definitionPost) = appendDefinitionHeaderName(`class`)
        sb.append(definitionPre)
        sb.appendLine()
        sb.appendLine(BASE_INCLUDE)

        sb.appendLine()
        sb.appendLine()

        val (obfuscated, mojang, intermediary, yarn, searge) = `class`.name
        val mappedParams = """
            "$obfuscated", "$mojang", "$intermediary", "$yarn", "$searge"
            """.trimIndent()

        sb.append("""
            /*
             * Minecraft class
             * Original: ${`class`.name.dottedNormalName}
             * Remapped: ${`class`.name.obfuscated}
             */
            namespace ${`class`.name.original} {
                static jclass findAlwaysSelf(JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                    return _env->FindClass(MinecraftSDK::getRemapped($mappedParams));
                };
            
                static jclass self(JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                    static jclass cachedClass = nullptr;
                    if (cachedClass == nullptr) {
                        cachedClass = findAlwaysSelf(_env);
                    }
                    return cachedClass;
                };
        """.trimIndent())
        sb.appendLine()
        insertFields(sb, `class`)
        insertMethods(sb, `class`)

        sb.appendLine("\n};")
        sb.appendLine()


        sb.append(definitionPost)
        dstFile.writeText(sb.toString())
    }

    private fun insertMethods(sb: StringBuilder, `class`: IClass) {
        `class`.methods.forEach { insertMethod(sb, it, `class`) }
    }

    private fun insertFields(sb: StringBuilder, `class`: IClass) {
        `class`.fields.forEach { insertField(sb, it, `class`) }
    }

    private fun insertField(sb: StringBuilder, field: IField, `class`: IClass) {

        val (cppType, second, third) = parseFieldJNIString(field)
        val isGetOrIs = if(cppType == "jboolean") "is" else "get"

        val (obfuscated, mojang, intermediary, yarn, searge) = field.name
        val mappedParams = """
            "$obfuscated", "$mojang", "$intermediary", "$yarn", "$searge"
            """.trimIndent()

        if(field.static)
            sb.append("""
                |
                |    // getter for static ${field.access.name.lowercase()} field ${`class`.name.dottedNormalName}#${`field`.name.normalName}
                |    [[maybe_unused]] static $cppType get_field_${field.name.nameWithoutCollision}(JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                |        const auto clazz = self();
                |        const auto fieldID = _env->GetStaticFieldID(clazz, MinecraftSDK::getRemapped($mappedParams), "${field.descriptor}");
                |        return _env->${second}(clazz, fieldID);
                |    };
                |
                |    // setter for static ${field.access.name.lowercase()} field ${`class`.name.dottedNormalName}#${`field`.name.normalName}
                |    [[maybe_unused]] static void set_field_${field.name.nameWithoutCollision}(const $cppType &value, JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                |        const auto clazz = self();
                |        const auto fieldID = _env->GetStaticFieldID(clazz, MinecraftSDK::getRemapped($mappedParams), "${field.descriptor}");
                |        return _env->${third}(clazz, fieldID, value);
                |    };
                |
            """.trimMargin())
        else {
            sb.append("""
                |
                |    // getter for ${field.access.name.lowercase()} field ${`class`.name.dottedNormalName}#${`field`.name.normalName}
                |    static $cppType get_field_${field.name.nameWithoutCollision}(const jobject &obj, JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                |        const auto fieldID = _env->GetFieldID(self(), MinecraftSDK::getRemapped($mappedParams), "${field.descriptor}");
                |        return _env->${second}(obj, fieldID);
                |    };
                |
                |    // setter for static ${field.access.name.lowercase()} field ${`class`.name.dottedNormalName}#${`field`.name.normalName}
                |    static void set_field_${field.name.nameWithoutCollision}(const jobject &obj, const $cppType &value, JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                |        const auto fieldID = _env->GetFieldID(self(), MinecraftSDK::getRemapped($mappedParams), "${field.descriptor}");
                |        return _env->${third}(obj, fieldID, value);
                |    };
                |
            """.trimMargin())
        }
    }

    private fun insertMethod(sb: StringBuilder, method: IMethod, `class`: IClass) {

        val (obfuscated, mojang, intermediary, yarn, searge) = method.name

        val mappedParams = """
            "$obfuscated", "$mojang", "$intermediary", "$yarn", "$searge"
            """.trimIndent()


        if(method.name.isInit)
            return

        val (argsTypes, result) = method.parsedDescriptor

        val args = argsTypes.mapIndexed { index, arg -> "const $arg&" to "arg$index" }.toMutableList()

        if (!method.static) {
            args.addFirst("const jobject&" to "obj")
        }
        val static = if(method.static) "Static" else ""
        val call = if(method.static) "clazz" else "obj"

        val argsString = args.joinToString(", ") { "${it.first} ${it.second}" }
        var argsNames = args.joinToString(", ") { it.second }

        fun updateArgs(): Boolean {
            if(!method.static && args.isNotEmpty()) {
                args.removeFirst();
                argsNames = args.joinToString(", ") { it.second }
            }
            return true;
        }

        sb.append("""
                |
                |    static jmethodID methodID_${method.name.nameWithoutCollision}(JNIEnv* _env = ${BASE_NAMESPACE}::env) {
                |       const auto clazz = self();
                |       return _env->Get${static}MethodID(clazz, MinecraftSDK::getRemapped($mappedParams), "${method.descriptor}");
                |    }
                |
                |    static $result ${method.name.nameWithoutCollision}($argsString${if(argsString.isNotEmpty()) ", " else ""}JNIEnv* _env = ${BASE_NAMESPACE}::env) {${if(call == "clazz") "\n|       const auto clazz = self();" else ""}
                |       const auto methodID = methodID_${method.name.nameWithoutCollision}();
                |       ${if(result != "void") "return " else ""}_env->Call$static${if(result == "void") "Void" else result.drop(1).upperFirstLetter()}Method($call, methodID${if (updateArgs() && args.isNotEmpty()) ", " else ""}$argsNames);
                |    };
                |    
            """.trimMargin())


    }


    private fun parseFieldJNIString(field: IField): Triple<String, String, String> {
        val get = "Get" + (if (field.static) "Static" else "")
        val set = "Set" + (if (field.static) "Static" else "")
        if (!field.fieldInfo.isPrimitive)
            return Triple(
                "jobject",
                get + "ObjectField",
                set + "ObjectField"
            )

        val method: String = field.fieldInfo.type.upperFirstLetter() + "Field"
        val `val` = "j" + field.fieldInfo.type.lowercase()

        return Triple(
            `val`,
            get + method,
            set + method
        )
    }

    private fun appendDefinitionHeaderName(`class`: IClass) = appendDefinitionHeaderName(`class`.name.underscoredNormalName)

    private fun appendDefinitionHeaderName(name: String): Pair<String, String> {
        return with("${name.uppercase()}_HPP") {
            """
            #ifndef $this
            #define $this
        """.trimIndent() to
        """
            #endif // $this
        """.trimIndent()
        }
    }

    private fun generateBaseCppFile(): String = """
        #include "sdk.hpp"

        MinecraftSDK::Mappings MinecraftSDK::selectedMapping = MinecraftSDK::OBFUSCATED;
        JavaVM* MinecraftSDK::vm = nullptr;
        JNIEnv* MinecraftSDK::env = nullptr;
    """.trimIndent()

    private fun generateBaseHeaderFile(classes: List<IClass>): String {
        val (startDef, endDef) = appendDefinitionHeaderName("MINECRAFT_SDK_BASE")

        val includes = classes.map { "#include <${it.name.normalName}.hpp>" }

        return """
            |${BASE_WARNING.trimIndent()}
            |
            |$startDef
            |
            |$JNI_INCLUDE
            |#define JNI_VERSION JNI_VERSION_1_6
            |
            |
            |#define JSTRING(str) ($BASE_NAMESPACE::env)->NewStringUTF(strz.c_str())
            |
            |#define EQUALS(x, y) (MinecraftSDK::isObjectsEqual(x, y))
            |
            |#define IS_INSTANCE(first, second) MinecraftSDK::env->IsInstanceOf(first, second)
            |
            |#define ENUM_ORDINAL(x) (MinecraftSDK::getEnumOrdinal(x))
            |
            |#define IS_NULL(env, jObject) (env)->IsSameObject(jObject, nullptr)
            |
            |#define JSTRING_TO_STD_STRING(jObj) \
            |    ([&]() -> std::string { \
            |        jstring jstr = static_cast<jstring>(jObj); \
            |        const char *nativeString = $BASE_NAMESPACE::env->GetStringUTFChars(jstr, nullptr); \
            |        std::string cppString(nativeString); \
            |        struct ReleaseString { \
            |            JNIEnv* env; \
            |            jstring jstr; \
            |            const char* nativeString; \
            |            ~ReleaseString() { \
            |                env->ReleaseStringUTFChars(jstr, nativeString); \
            |            } \
            |        } release{$BASE_NAMESPACE::env, jstr, nativeString}; \
            |        return cppString; \
            |    })()
            |
            |class $BASE_NAMESPACE {
            |public:
            |    enum Mappings {
            |        OBFUSCATED,
            |        MOJANG,
            |        INTERMEDIARY,
            |        YARN,
            |        SEARGE
            |    };
            |    
            |    static jint getEnumOrdinal(jobject enumObject, JNIEnv* _env = MinecraftSDK::env) {
            |        jclass enumClass = _env->GetObjectClass(enumObject);
            |        auto ordinalFieldID = _env->GetFieldID(enumClass, "ordinal", "I");
            |
            |        jint ordinal = _env->GetIntField(enumObject, ordinalFieldID);
            |        return ordinal;
            |    }
            | 
            |    static bool isObjectsEqual(const jobject &obj1, const jobject &obj2, JNIEnv* env = MinecraftSDK::env) {
            |        if (obj1 == nullptr || obj2 == nullptr) {
            |            return false;
            |        }
            |
            |        if(env->IsSameObject(obj1, obj2)) {
            |            return true;
            |        }
            |
            |        return false;
            |    }
            | 
            |    static Mappings selectedMapping;
            |
            |    static JavaVM* vm;
            |    static JNIEnv* env;
            |    
            |    static const char *getRemapped(
            |        const char *obfuscated,
            |        const char *mojang,
            |        const char *intermediary,
            |        const char *yarn,
            |        const char *searge
            |    ) {
            |        switch (selectedMapping) {
            |            case OBFUSCATED: return obfuscated;
            |            case MOJANG: return mojang;
            |            case INTERMEDIARY: return intermediary;
            |            case YARN: return yarn;
            |            case SEARGE: return searge;
            |        }
            | 
            |        return obfuscated; // if not found...
            |    }
            |    
            |    static int InitializeSDK(const Mappings &mapping = OBFUSCATED) {
            |        jsize count;
            |    
            |        if (JNI_GetCreatedJavaVMs(&vm, 1, &count) != JNI_OK || count == 0) {
            |            return JNI_ERR;
            |        }
            |        
            |        JavaVMAttachArgs attach_args;
            |        attach_args.version = JNI_VERSION;
            |    
            |        if (jint result = vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION); result == JNI_EDETACHED) {
            |          	if (result = vm->AttachCurrentThread(reinterpret_cast<void **>(&env), &attach_args); result != JNI_OK) {
            |          	    return JNI_ERR;
            |          	}
            |        }
            | 
            |        selectedMapping = mapping;
            |        return JNI_OK;
            |    }
            |    
            |};
            |
            |$endDef
            |
            |// by sqlerrorthing with ❤️❤️❤️
        """.trimMargin()
    }
}